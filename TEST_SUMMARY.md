# Test Summary — ACME Certificate Lifecycle Agent

All 155 tests pass in 28.99 seconds on Python 3.12.8 / macOS arm64 (2026-02-22). All suites verified including full Pebble integration lifecycle, DNS-01 challenge support, revocation (unit + Pebble), planner validation, checkpoint/resume, retry scheduler, and atomic writes.

## Atomic Write Tests (12 tests · `tests/test_atomic_writes.py`)

The atomic writes suite validates safe filesystem operations for certificate storage — no network, no Pebble. Three test groups: **text atomic writes** (5 tests) cover creating files, overwriting existing files, cleaning up temporary files, creating parent directories, and handling cleanup on write failure; **byte atomic writes** (4 tests) cover binary-mode file operations and large file handling; **integration** (3 tests) cover PEM file writes, multiple concurrent writes to the same directory, and concurrent writes to different files. All operations are fully atomic — temporary files are cleaned up on failure, and no partial writes are visible to other processes.

## Unit Tests (27 tests · `tests/test_unit_acme.py`)

The unit suite validates the ACME protocol layer in complete isolation — no network, no Pebble, no Anthropic API key. HTTP calls are intercepted by the `responses` library. Six tests cover `acme/jws.py`: RSA-2048 account key generation, JWK thumbprint determinism, HTTP-01 key-authorization construction, JWS signing in both JWK mode (used for `newAccount`) and KID mode (used for all subsequent requests), and round-trip persistence of the account key with enforced `0o600` file permissions. Four tests cover `acme/crypto.py`: domain RSA key generation, PEM encoding, and CSR creation for both single-domain and multi-SAN orders. The remaining seventeen tests cover `acme/client.py`: directory discovery, nonce retrieval, account registration without EAB (verifying the `externalAccountBinding` field is absent), order creation, authorization polling on both the valid and invalid paths, error handling on non-2xx responses, certificate revocation via `POST /revokeCert`, and nine tests for the `EabAcmeClient` hierarchy — verifying default directory URLs for ZeroSSL and Sectigo, the full subclass chain, the regression that `create_account` is not duplicated in leaf classes, `make_client()` factory dispatch for both new providers, and EAB injection/omission behaviour in `EabAcmeClient.create_account()`.

## Unit Tests — Failure Scenarios (9 tests · `tests/test_unit_failure_scenarios.py`)

Focused error case coverage for ACME protocol failures — no network, no Pebble. Covers nine failure modes: **ACME challenge failure** — `respond_to_challenge()` succeeds but `poll_authorization()` returns `status: invalid`; **invalid CSR** — server rejects with `urn:ietf:params:acme:error:badCSR` (400); **expired nonce with auto-retry** — first POST returns `badNonce` with fresh nonce in `Replay-Nonce` header, client retries with fresh nonce, succeeds on second attempt; **nonce retry exhaustion** — all three attempts (0, 1, 2) return `badNonce`, final attempt raises `AcmeError(400, badNonce)` since no more retries are permitted; **network timeout** — `ConnectTimeout` on directory fetch propagates (not suppressed); **invalid directory URL (connection error)** — `ConnectionError` on unreachable host propagates; **invalid directory URL (404)** — directory returns 404, `raise_for_status()` converts to `HTTPError`, exception propagates; **malformed finalize response** — server returns invalid JSON in finalize response; **rate limit (429)** — server returns 429 with `Retry-After` header.

## DNS-01 Challenge Tests (45 tests · `tests/test_dns_challenge.py`)

Full coverage of DNS-01 challenge support — Cloudflare, Route53, Google Cloud DNS. No network, no DNS credentials, no Pebble required; all provider API calls are mocked. Seven test groups: **`compute_dns_txt_value`** (5 tests) verify SHA-256 → base64url correctness against a known vector, absence of padding characters, determinism, collision resistance, and valid base64url alphabet; **`make_dns_provider` factory** (7 tests) verify correct dispatch to each provider class, `ValueError` for unknown providers, and `ImportError` with actionable `uv sync --extra` install hints for all three providers when their optional libraries are not installed; **`CloudflareDnsProvider`** (6 tests) verify create with explicit zone ID, auto-discovery via `zones.list()` when zone ID is empty, idempotent create (skips if identical record exists), delete by name+content match, error swallowing on delete failure, and silent no-op when record not found; **`Route53DnsProvider`** (5 tests) verify UPSERT with double-quote-wrapped TXT value as required by Route53, explicit zone ID usage, auto-discovery via `list_hosted_zones_by_name()`, DELETE action in change batch, and error swallowing; **`GoogleCloudDnsProvider`** (3 tests) verify `add_record_set()+changes.create()` create chain, `delete_record_set()+changes.create()` delete chain, and error swallowing; **`order_initializer` with DNS-01** (5 tests) verify that `dns-01` challenge URL is selected (not `http-01`), `auth_domains` is populated from `authz["identifier"]["value"]`, `dns_txt_values` contains the correct computed values, `dns_txt_values` is empty for HTTP-01 modes, and an `error_log` entry is returned when no `dns-01` challenge is present; **`challenge_setup`/`_cleanup_challenge` DNS branches** (7 tests) verify that `create_txt_record()` is called for every domain, propagation sleep fires with the configured duration, sleep is skipped when set to 0, `delete_txt_record()` is called for every domain during cleanup, cleanup continues after a partial delete failure, and `_dns_provider` is reset to `None` after cleanup; **config validation** (7 tests) verify that `dns` is accepted as a valid `HTTP_CHALLENGE_MODE`, invalid modes are rejected, `CLOUDFLARE_API_TOKEN` is required in dns+cloudflare mode, `GOOGLE_PROJECT_ID` is required in dns+google mode, Route53 requires no mandatory credentials (uses the boto3 credential chain), and existing `standalone`/`webroot` validation is unaffected.

## Knowledge Base Tests (5 tests · `tests/test_kb.py`)

The knowledge base suite validates document chunking and semantic search functionality — no network or external services required. `test_markdown_splits_into_sections` verifies that markdown files are correctly split into chunks at section boundaries (identified by heading markers). `test_markdown_chunk_contains_full_text` ensures that no text is lost during chunking and each section is complete. `test_python_extracts_top_level_functions` confirms that Python modules extract top-level function definitions as distinct chunks. `test_python_extracts_class_overview_and_methods` verifies that class definitions and their method signatures are extracted as separate chunks for fine-grained indexing. `test_search_returns_semantically_relevant_result` exercises the FAISS semantic search index, confirming that keyword-based queries return contextually relevant results from the indexed knowledge base.

## Checkpoint Tests (10 tests · `tests/test_checkpoint.py`)

The checkpoint suite exercises LangGraph's `MemorySaver` checkpoint persistence mechanism — no Pebble required, all ACME operations are mocked. Five test groups: **basic mechanics** (2 tests) verify that the graph creates checkpoints after complete runs and that `get_state_history()` yields all node executions with correct step counters; **interrupt/resume** (3 tests) verify that the graph can be paused before any node via `interrupt_before`, resumed successfully from that point, and that deep interrupts preserve per-domain ACME state (current_order, current_domain); **state integrity** (3 tests) verify that config fields never mutate across checkpoints, that progress tracking fields are correct at run end, and that LLM message history accumulates across checkpoints via the `add_messages` reducer; **thread isolation** (1 test) verifies that different `thread_id` values maintain independent checkpoint histories; **advanced operations** (1 test) verifies that `graph.update_state()` can inject modified state before resuming.

## Retry Scheduler Tests (12 tests · `tests/test_retry_scheduler.py`)

Synchronous and asynchronous retry scheduling with exponential backoff — no network or external services required. Five synchronous tests verify: when `retry_not_before=None`, scheduler returns immediately (no state mutation); when retry time is in the past, scheduler proceeds without blocking; when retry time is in the future, `time.sleep()` blocks for the correct duration; after applying backoff, `retry_not_before` is cleared from state; multi-second backoff durations are handled correctly. Four asynchronous tests verify the async variants with `asyncio.sleep()` instead of `time.sleep()`, confirming that async backoff does not block the event loop. Two integration tests verify scheduler behavior paired with the error_handler node and concurrent multi-domain retries with independent backoff timers.

## Planner Validation Tests (12 tests · `tests/test_planner_validation.py`)

LLM output validation and hallucinated domain stripping — no network, no Pebble, LLM output is mocked. Nine unit tests of the `_parse_and_validate()` function: invalid JSON triggers fallback with all domains in `routine_renewals`; hallucinated domains in `urgent_renewals`, `routine_renewals`, and `skip` are stripped; mixed real and hallucinated domains preserve the real ones; lookalike domains (typos) are stripped; missing managed domains are added to `routine_renewals`; all missing domains trigger recovery; all hallucinated domains trigger fallback to queue all domains for renewal. Three node-level tests of the `renewal_planner` node: hallucinated domains are stripped from state; invalid JSON causes the node to queue all domains; urgent renewals appear before routine in `pending_renewals`. Collectively, these tests ensure the planner cannot introduce new domains or cause protocol violations.

## Lifecycle Tests (2 tests · `tests/test_lifecycle_pebble.py`)

The lifecycle suite exercises the complete TLS certificate lifecycle end-to-end against a local Pebble ACME stub, with LLM nodes mocked so no Anthropic API key is required. `test_certificate_lifecycle` walks through four sequential steps: **Issue** — the agent runs with no certificate on disk and completes the full ACME flow, writing `cert.pem`, `chain.pem`, `fullchain.pem`, `privkey.pem` (mode `0o600`), and `metadata.json`; **Expiry detection** — `days_until_expiry()` is called on the issued certificate to confirm the scanner's threshold logic correctly identifies a cert as needing renewal when `renewal_threshold_days` exceeds the remaining validity; **Renew** — the agent re-runs with `renewal_threshold_days=9999`, triggering a full re-issuance that produces a certificate with a provably different serial number and an updated `metadata.expires_at`; **Revoke** — the renewed certificate is revoked via `client.revoke_certificate()`, with Pebble returning 200 OK. `test_revoke_original_cert_after_renewal` extends this by issuing a cert, renewing it, and then revoking the original (now superseded) certificate using RFC 5280 reason code 4, confirming that Pebble accepts revocation of a cert that is no longer the current one.

## Integration Tests (4 tests · `tests/test_integration_pebble.py`)

The integration suite runs the full LangGraph agent graph against Pebble, verifying that all nodes wire together correctly. `test_full_renewal_flow` is the happy-path end-to-end test: it invokes the compiled graph from `certificate_scanner` through `summary_reporter`, confirms the domain appears in `completed_renewals` with an empty `failed_renewals`, and validates that all five output files exist on disk with correct permissions and a populated `metadata.json`. `test_second_run_reuses_account` runs the graph twice in sequence and asserts that the second run reuses the persisted account key — calling `POST /newAccount` with `onlyReturnExisting=True` rather than registering a new account — confirming that account state survives across agent runs. `test_no_renewal_needed` issues a fresh certificate and then re-runs the graph with a planner mock that returns `skip: [domain]`, verifying that `pending_renewals` remains empty, the agent exits via the `no_renewals` conditional edge, and both `completed_renewals` and `failed_renewals` are empty lists. `test_full_renewal_flow_dns01` is the DNS-01 happy-path: runs the full graph with `HTTP_CHALLENGE_MODE=dns` and a mocked DNS provider (no real Cloudflare credentials needed), verifies `create_txt_record()` called exactly once during challenge setup, `delete_txt_record()` called exactly once during cleanup, and `cert.pem` written to disk with a valid expiry date.

## Revocation Tests (15 tests · `tests/test_revocation.py`)

Unit and graph topology tests for certificate revocation — no Pebble required, all ACME operations are mocked. Five groups: **router** (5 tests) verify that `pick_next_revocation_domain` pops the first domain from `revocation_targets`, sets `current_revocation_domain`, handles the last and empty domain cases correctly, and that `revocation_loop_router` routes to `next_domain` when targets remain and to `all_done` when empty; **revoker** (3 tests) verify that `cert_revoker` posts to `/revokeCert` successfully (domain added to `revoked_domains`), handles a missing cert file gracefully (domain added to `failed_revocations`), and handles an ACME error without raising; **reporter** (3 tests) verify that `revocation_reporter` generates an LLM summary reflecting revoked and failed domains, and continues gracefully when the LLM call itself fails; **graph topology** (1 test) verifies the compiled revocation graph has the correct nodes and edges; **graph flow** (3 tests) verify single-domain, multi-domain, and partial-failure scenarios through the full graph.

## Revocation Pebble Tests (3 tests · `tests/test_revocation_pebble.py`)

End-to-end revocation against a live Pebble instance — LLM nodes are mocked. Each test first issues a certificate via the main agent graph, then invokes the revocation graph. `test_revocation_graph_basic_against_pebble` verifies that a freshly issued cert is successfully revoked (reason=0, domain in `revoked_domains`, `failed_revocations` empty). `test_revocation_reason_codes_against_pebble` confirms Pebble accepts reason=1 (keyCompromise). `test_revocation_nonexistent_cert_against_pebble` confirms that attempting to revoke a domain with no cert on disk lands in `failed_revocations` with a non-empty `error_log` rather than raising an unhandled exception.
