# Test Summary — ACME Certificate Lifecycle Agent

All 46 tests pass in 28.62 seconds on Python 3.12.8 / macOS arm64 (2026-02-21). All suites verified including full Pebble integration lifecycle.

## Unit Tests (27 tests · `tests/test_unit_acme.py`)

The unit suite validates the ACME protocol layer in complete isolation — no network, no Pebble, no Anthropic API key. HTTP calls are intercepted by the `responses` library. Six tests cover `acme/jws.py`: RSA-2048 account key generation, JWK thumbprint determinism, HTTP-01 key-authorization construction, JWS signing in both JWK mode (used for `newAccount`) and KID mode (used for all subsequent requests), and round-trip persistence of the account key with enforced `0o600` file permissions. Four tests cover `acme/crypto.py`: domain RSA key generation, PEM encoding, and CSR creation for both single-domain and multi-SAN orders. The remaining seventeen tests cover `acme/client.py`: directory discovery, nonce retrieval, account registration without EAB (verifying the `externalAccountBinding` field is absent), order creation, authorization polling on both the valid and invalid paths, error handling on non-2xx responses, certificate revocation via `POST /revokeCert`, and nine new tests for the `EabAcmeClient` hierarchy — verifying default directory URLs for ZeroSSL and Sectigo, the full subclass chain, the regression that `create_account` is not duplicated in leaf classes, `make_client()` factory dispatch for both new providers, and EAB injection/omission behaviour in `EabAcmeClient.create_account()`.

## Unit Tests — Failure Scenarios (7 tests · `tests/test_unit_failure_scenarios.py`)

Focused error case coverage for ACME protocol failures — no network, no Pebble. Covers five failure modes: **ACME challenge failure** — `respond_to_challenge()` succeeds but `poll_authorization()` returns `status: invalid`; **invalid CSR** — server rejects with `urn:ietf:params:acme:error:badCSR` (400); **expired nonce with auto-retry** — first POST returns `badNonce` with fresh nonce in `Replay-Nonce` header, client retries with fresh nonce, succeeds on second attempt; **nonce retry exhaustion** — all three attempts (0, 1, 2) return `badNonce`, final attempt raises `AcmeError(400, badNonce)` since no more retries are permitted; **network timeout** — `ConnectTimeout` on directory fetch propagates (not suppressed); **invalid directory URL (connection error)** — `ConnectionError` on unreachable host propagates; **invalid directory URL (404)** — directory returns 404, `raise_for_status()` converts to `HTTPError`, exception propagates.

## Knowledge Base Tests (5 tests · `tests/test_kb.py`)

The knowledge base suite validates document chunking and semantic search functionality — no network or external services required. `test_markdown_splits_into_sections` verifies that markdown files are correctly split into chunks at section boundaries (identified by heading markers). `test_markdown_chunk_contains_full_text` ensures that no text is lost during chunking and each section is complete. `test_python_extracts_top_level_functions` confirms that Python modules extract top-level function definitions as distinct chunks. `test_python_extracts_class_overview_and_methods` verifies that class definitions and their method signatures are extracted as separate chunks for fine-grained indexing. `test_search_returns_semantically_relevant_result` exercises the FAISS semantic search index, confirming that keyword-based queries return contextually relevant results from the indexed knowledge base.

## Lifecycle Tests (2 tests · `tests/test_lifecycle_pebble.py`)

The lifecycle suite exercises the complete TLS certificate lifecycle end-to-end against a local Pebble ACME stub, with LLM nodes mocked so no Anthropic API key is required. `test_certificate_lifecycle` walks through four sequential steps: **Issue** — the agent runs with no certificate on disk and completes the full ACME flow, writing `cert.pem`, `chain.pem`, `fullchain.pem`, `privkey.pem` (mode `0o600`), and `metadata.json`; **Expiry detection** — `days_until_expiry()` is called on the issued certificate to confirm the scanner's threshold logic correctly identifies a cert as needing renewal when `renewal_threshold_days` exceeds the remaining validity; **Renew** — the agent re-runs with `renewal_threshold_days=9999`, triggering a full re-issuance that produces a certificate with a provably different serial number and an updated `metadata.expires_at`; **Revoke** — the renewed certificate is revoked via `client.revoke_certificate()`, with Pebble returning 200 OK. `test_revoke_original_cert_after_renewal` extends this by issuing a cert, renewing it, and then revoking the original (now superseded) certificate using RFC 5280 reason code 4, confirming that Pebble accepts revocation of a cert that is no longer the current one.

## Integration Tests (3 tests · `tests/test_integration_pebble.py`)

The integration suite runs the full LangGraph agent graph against Pebble, verifying that all nodes wire together correctly. `test_full_renewal_flow` is the happy-path end-to-end test: it invokes the compiled graph from `certificate_scanner` through `summary_reporter`, confirms the domain appears in `completed_renewals` with an empty `failed_renewals`, and validates that all five output files exist on disk with correct permissions and a populated `metadata.json`. `test_second_run_reuses_account` runs the graph twice in sequence and asserts that the second run reuses the persisted account key — calling `POST /newAccount` with `onlyReturnExisting=True` rather than registering a new account — confirming that account state survives across agent runs. `test_no_renewal_needed` issues a fresh certificate and then re-runs the graph with a planner mock that returns `skip: [domain]`, verifying that `pending_renewals` remains empty, the agent exits via the `no_renewals` conditional edge, and both `completed_renewals` and `failed_renewals` are empty lists.
